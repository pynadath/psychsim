from psychsim_agents.helper_functions import *from psychsim.agent import Agentfrom psychsim.world import Worldimport randomdef div(x, y):    if y == 0: return 0    return x / ydef mean(samples):    sum_samples = 0.0    for sample_y in samples:        for sample in sample_y:            sum_samples += sample[2]    return sum_samples / len(samples)class Example:    def __init__(self):        self.num_x = 10        self.num_y = 10        num_samples = 100        self.world = World()        self.agent = Agent('The Agent')        self.world.addAgent(self.agent)        self.world.setOrder([self.agent])        self.var_x = self.world.defineState(self.agent.name, 'var_x', float, lo=0, hi=self.num_x)        self.var_y = self.world.defineState(self.agent.name, 'var_y', float, lo=0, hi=self.num_y)        self.result1 = self.world.defineState(self.agent.name, 'result1', float, lo=0,                                              hi=div(self.num_x, self.num_y))        self.result2 = self.world.defineState(self.agent.name, 'result2', float, lo=0,                                              hi=div(self.num_x, self.num_y))        self.world.addDependency(self.result2, self.var_x)        self.world.addDependency(self.result2, self.var_y)        self.world.addDependency(self.result1, self.var_x)        self.world.addDependency(self.result1, self.var_y)        # division using denominator approximation        divide = self.agent.addAction({'verb': 'operation', 'action': 'divide'})        tree1 = makeTree(setToDivideMatrix(self.result1, self.var_x, self.var_y, 1.0 / num_samples))        self.world.setDynamics(self.result1, divide, tree1)        # division using linear sampling        samples = get_bivariate_samples(            div, 0, self.num_x, 0, self.num_y, num_samples, num_samples)        self.sample_mean = mean(samples)        tree2 = makeTree(tree_from_bivariate_samples(            self.result2, self.var_x, self.var_y, samples, 0, num_samples - 1, 0, num_samples - 1))        self.world.setDynamics(self.result2, divide, tree2)    def run_it(self):        se_1 = 0.0        se_2 = 0.0        max_se = 0.0        for i in range(self.num_x * self.num_y):            x = random.random() * self.num_x            self.world.setFeature(self.var_x, x)            y = random.random() * self.num_y            self.world.setFeature(self.var_y, y)            self.world.step()            print "_____________________________________"            print "Calculating:                  " + str(x) + "/" + str(y)            real = div(x, y)            print "Expected result:              " + str(real)            result_1 = float(str(self.world.getFeature(self.result1)).replace("100%\t", ""))            print "PsychSim den. approx. result: " + str(result_1)            se_1 += (real - result_1) ** 2            result_2 = float(str(self.world.getFeature(self.result2)).replace("100%\t", ""))            print "PsychSim lin. samp. result:   " + str(result_2)            se_2 += (real - result_2) ** 2            max_se += (real - self.sample_mean) ** 2        num_samples = self.num_x * self.num_y        rmse_1 = (se_1 / num_samples) ** 0.5        rmse_2 = (se_2 / num_samples) ** 0.5        max_rmse = (max_se / num_samples) ** 0.5        print "====================================="        print "RMSE_1      = " + str(rmse_1)        print "RMSE_2      = " + str(rmse_2)        print "RMSE_MAX    = " + str(max_rmse)        print "_____________________________________"        print "RMSE_NORM_1 = " + str(rmse_1 / max_rmse)        print "RMSE_NORM_2 = " + str(rmse_2 / max_rmse)Example().run_it()